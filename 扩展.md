Kotlin 类似于C# 和 Gosu, 提供给类扩展新方法但又不需要继承，也不需要任何设计模式，不需要像装饰着模式来扩展。它通过特殊的定义就可以做到，它的名字就叫做扩展。Kotlin支持扩展方法和扩展属性。

## 扩展方法

定义一个扩展方法，我们需要在类型前加一个前缀，换句话说，就像下面的代码。添加一个`swap`方法给`MutableList<Int>:`类

```Kotlin
fun MutableList<Int>.swap(index1: Int, index2: Int) {
  val tmp = this[index1] // 'this' corresponds to the list
  this[index1] = this[index2]
  this[index2] = tmp
}
```

上面代码中的`this`这个关键字是就是`MutableList<Int>:`类。现在我们可以调用`swap`这个方法在任何`MutableList<Int>:`类中，就像下面的代码。

```Kotlin
val l = mutableListOf(1, 2, 3)
l.swap(0, 2) // 'this' inside 'swap()' will hold the value of 'l'
```

当然，这个方法对任何`MutableList<Int>:`类型都可以使用，我们可以把它做成泛型。

```Kotlin
fun <T> MutableList<T>.swap(index1: Int, index2: Int) {
  val tmp = this[index1] // 'this' corresponds to the list
  this[index1] = this[index2]
  this[index2] = tmp
}
```

上面我们定义成泛型(在方法名前加范型)，关于泛型请查看[泛型](./泛型)

## 扩展是被静态解析的

扩展实际上不会修改类本身，通过定义一个扩展，你是不能插入新的方法到类中，虽然看起来加入了一个新方法到类中，但是你只是可以用`.`来访问而已，别想太多了。

我们想要再次强调，扩展方法是通过静态调度的，换句话说，扩展不是被扩展类虚拟出的类型，如果类有一个方法和一个扩展是一样的名字，那么扩展永远比不过类本来的方法。当被调用的时候，例子如下。

```Kotlin
class C {
    fun foo() { println("member") }
}

fun C.foo() { println("extension") }
```

如果我们调用`c.foo()`，会输出"member"而不是"extension"。

## 可空接收者

注意扩展可以扩展一个可空类型，例如扩展可以被任何变量调用，即使这个值是null，并且可以检查`this==null`。下面这个例子写了后，就允许你调用`toString()`而不需要检查是否为`null`。

```Kotlin
fun Any?.toString(): String {
    if (this == null) return "null"
    // after the null check, 'this' is autocast to a non-null type, so the toString() below
    // resolves to the member function of the Any class
    return toString()
}
```

