类似于Java，Kotlin中的类也可以具有类型参数：
```Kotlin
class Box<T>(t: T) {
  var value = t
}
```

当我们需要创建一个类似于Box这样的类实例时，就需要提供一个类型参数。

```Kotlin
val box: Box<Int> = Box<Int>(1)
```

当此类型参数可以被推断出，例如，通过构造器参数或通过其他方式，可以省略类型参数。

```Kotlin
val box = Box(1) // 1 为In, 此时编译器可以得知我们是要初始化 Box<Int>
```

###集合声明变量(Declaration-site variance)

假设我们有一个泛型接口Source<T>，在它当中没有任何方法使用类型T作为参数，只存在返回T类型的方法。

```Java
// Java
interface Source<T> {
	T nextT();
}
```

此时，可以将一个类型为Source<String>的实例的引用赋值到一个类型为Source<Object>当中，尽管其中没有任何自定义的方法可以调用，但Java并不知道，仍然不会允许这样的操作：

```Java
// Java
void demo(Source<String> strs) {
	Source<Object> objects = strs; // 在Java中禁用
}
```

为了解决这个问题，我们需要这样来定义该泛型：Source<? extends Objcet>，这看上去没有什么区别，我们可以像上述代码那样进行调用，而不会报错。

在Kotlin中，有一种方式可以对编译器解释这种情况。称为“集合声明变量（declaration-site variance）”：我们可以标注Source中类型参数T必须由Source<T>的成员返回或产生，此标注将一直起作用。Kotlin中提供了out修饰符来达到这个效果：

```Kotlin
abstract class Source<out T> { // out 修饰符
	fun nextT(): T
}

fun demo(strs: Source<String>) {
	val objects: Source<Any> = strs 
	// 由于T有一个out修饰符，所以允许此操作
}
```

规则：