类似于Java，Kotlin中的类也可以具有类型参数：
```Kotlin
class Box<T>(t: T) {
  var value = t
}
```

当我们需要创建一个类似于Box这样的类实例时，就需要提供一个类型参数。

```Kotlin
val box: Box<Int> = Box<Int>(1)
```

当此类型参数可以被推断出，例如，通过构造器参数或通过其他方式，可以省略类型参数。

```Kotlin
val box = Box(1) // 1 为In, 此时编译器可以得知我们是要初始化 Box<Int>
```

###泛型限定修饰符(Declaration-site variance)

假设我们有一个泛型接口Source<T>，在它当中没有任何方法使用类型T作为参数，只存在返回T类型的方法。

```Java
// Java
interface Source<T> {
	T nextT();
}
```

此时，尝试将一个类型为Source<String>的实例的引用赋值到一个类型为Source<Object>当中，尽管其中没有任何自定义的方法可以调用，但Java并不知道，仍然不会允许这样的操作：

```Java
// Java
void demo(Source<String> strs) {
	Source<Object> objects = strs; // 在Java中禁用
}
```

为了解决这个问题，我们需要这样来定义该泛型：Source<? extends Objcet>，限定了类型参数必须为Object的子类型，我们可以像上述代码那样进行调用，而不会报错。

在Kotlin中，有一种方式可以对编译器解释这种情况。称为“集合声明变量（declaration-site variance）”：我们可以标注Source中类型参数T必须为T的子类型。Kotlin中提供了out修饰符来达到这个效果：

```Kotlin
abstract class Source<out T> { // out 修饰符
	fun nextT(): T
}

fun demo(strs: Source<String>) {
	val objects: Source<Any> = strs 
	// 由于T有一个out修饰符，所以允许此操作
}
```

规则：当一个泛型类C的类型参数T添加了out修饰符，此类型参数T只能用于限定返回值的类型。

我们可以认为类C与其类型参数T是共同变化的，out T 仅能用于获取该类型，而不能用于设置out T类型，out修饰符被称为一种分歧标注，相当于Java中的<? extends T>

相对于out修饰符，Kotlin提供了相对的in修饰符，相当于Java中的<? super T>，仅能用于设置此类型，而不能获取此类型。来看一个例子：

```Kotlin
abstract class Comparable<in T> {
	fun compareTo(other: T): Int
}

fun demo(x: Comparable<Number>) {
	x.compareTo(1.0) // 1.0为Double类型, 是Number的子类型
  //因此, 我们可以给Comparable<Double>赋值
	val y: Comparable<Double> = x // OK!
}
```

我们相信in和out可以自解释，用一种更为简单的记忆方式：
用in来设置，out来获取。