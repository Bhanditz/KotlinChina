### 声明属性
在Kotlin中类可以有属性，想要属性是可变的使用Var关键字或想要属性仅仅可读使用关键字val声明。
```Kotlin
public class Address { 
  public var name: String = ...
  public var street: String = ...
  public var city: String = ...
  public var state: String? = ...
  public var zip: String = ...
}
```

要使用属性，我们可以像java中的字段一样指定他的名字。
```Kotlin
fun copyAddress(address: Address): Address {
  val result = Address() // there's no 'new' keyword in Kotlin
  result.name = address.name // accessors are called
  result.street = address.street
  // ...
  return result
}
```

### Getter和Setter
声明一个属性的全语法是：
```Kotlin
var <propertyName>: <PropertyType> [= <property_initializer>]
  [<getter>]
  [<setter>]
```

在这个初始化中，getter和setter是可选的。属性类型是可选的,前提是：如果它可以从初始化中推断出或在基类成员中被覆盖

例子：
```Kotlin
var allByDefault: Int? // error: explicit initializer required, default getter and setter implied
var initialized = 1 // has type Int, default getter and setter
```
一个可读属性声明的全部语句不同于可变属性的两种方式：可读属性是用关建字
val代表var并且不允许有setter:
```Kotlin
val simple: Int? // has type Int, default getter, must be initialized in constructor
val inferredType = 1 // has type Int and a default getter
```

当然我们也可以写自定义存取，非常类似于普通的方法一样正确在属性的内部。下面是一个自定义getter的例子
```Kotlin
val isEmpty: Boolean
  get() = this.size == 0
```

一个自定义setter是这样的：
```Kitlin
var stringRepresentation: String
  get() = this.toString()
  set(value) {
    setDataFromString(value) // parses the string and assigns values to other properties
  }
```

惯例上，setter参数的名字是value，但是你也可以根据自己的喜欢选择不同的名字。

如果你需要改变访问的可见性或者想为其添加注解，但是不需要改变默认的实现，你可以定义一个访问但是不定义他的方法体：
```Kotlin
var setterVisibility: String = "abc" // Initializer required, not a nullable type
  private set // the setter is private and has the default implementation

var setterWithAnnotation: Any?
  @Inject set // annotate the setter with Inject
```

### 后备字段
Kotlin中的类不能有字段，然而有时当我们自定义一个访问时有一个后备字段是非常必要的。为了达到这个目的，Kotlin为我们提供了一个自动后备字段它可以使用fidle标识符号来访问:
```Kotlin
var counter = 0 // the initializer value is written directly to the backing field
  set(value) {
    if (value >= 0)
      field = value
  }
```

field标识符仅仅被用来访问属性的。

编译器会监听着访问体，如果他们使用后备字段(或访问的实现在默认的左边)，那么后备字段就会被生成，否则则不会生成。